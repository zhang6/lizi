<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ²‰æµ¸å¼æ‰‹åŠ¿å¡”ç½—ç‰Œ</title>
    
    <!-- ä¾èµ–åº“ CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        /* å…¨å±€æ ·å¼é‡ç½® */
        body { margin: 0; padding: 0; overflow: hidden; background-color: #050505; font-family: "PingFang SC", "Microsoft YaHei", sans-serif; user-select: none; }
        
        /* UI å®¹å™¨ */
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; }

        /* åŠ è½½é®ç½© */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999; display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: #d4af37;
            transition: opacity 0.5s ease;
        }
        .spinner { width: 50px; height: 50px; border: 3px solid rgba(212, 175, 55, 0.3); border-radius: 50%; border-top-color: #d4af37; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* è¿”å›é¦–é¡µæŒ‰é’® */
        #home-btn {
            position: absolute; top: 20px; left: 70px;
            background: rgba(20, 20, 30, 0.6); border: 1px solid rgba(212, 175, 55, 0.5);
            color: #d4af37; padding: 8px 16px; border-radius: 20px;
            cursor: pointer; font-size: 12px; transition: all 0.3s;
            text-decoration: none; display: flex; align-items: center; gap: 5px;
        }
        #home-btn:hover { background: rgba(212, 175, 55, 0.2); transform: translateX(-2px); }

        /* æ¨¡å¼åˆ‡æ¢æŒ‰é’® */
        #mode-switch {
            position: absolute; top: 20px; right: 20px;
            background: rgba(20, 20, 30, 0.6); border: 1px solid rgba(212, 175, 55, 0.5);
            color: #d4af37; padding: 8px 16px; border-radius: 20px;
            cursor: pointer; font-size: 12px; transition: all 0.3s;
        }
        #mode-switch:hover { background: rgba(212, 175, 55, 0.2); }

        /* å†å²é¢æ¿ - æç®€æ— è¾¹æ¡†é£æ ¼ */
        #history-panel {
            position: absolute; top: 70px; left: 20px; width: auto; max-height: 70vh;
            background: transparent; 
            border-radius: 8px; overflow-y: auto; padding: 0;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.4s;
            transform: translateX(-250px); opacity: 0;
            pointer-events: none;
            -ms-overflow-style: none; scrollbar-width: none;
        }
        #history-panel::-webkit-scrollbar { display: none; }

        #history-panel.open { 
            transform: translateX(0); 
            opacity: 1; 
            pointer-events: auto;
        }
        
        #history-toggle {
            position: absolute; top: 20px; left: 20px; z-index: 11;
            width: 40px; height: 40px; 
            background: rgba(0, 0, 0, 0.3); border: none;
            border-radius: 50%; color: #d4af37; font-size: 20px;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }
        #history-toggle:hover { transform: scale(1.1); background: rgba(212, 175, 55, 0.2); }

        /* å†å²åˆ—è¡¨é¡¹ - çº¯å›¾è¡¨é£æ ¼ï¼Œæ— çº¿æ¡ */
        .history-item { 
            margin-bottom: 15px; 
            display: flex; align-items: center; 
            opacity: 0; animation: slideIn 0.3s forwards;
            background: rgba(0,0,0,0.4); border-radius: 8px; padding: 5px 10px 5px 5px;
            backdrop-filter: blur(5px);
        }
        @keyframes slideIn { from { opacity:0; transform:translateX(-10px); } to { opacity:1; transform:translateX(0); } }
        
        .history-thumb { 
            width: 36px; height: 56px; 
            background-color: #222; margin-right: 10px; 
            border-radius: 4px; 
            background-size: cover; background-position: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            flex-shrink: 0;
        }
        .history-info { display: flex; flex-direction: column; }
        .history-info h4 { margin: 0; color: #eee; font-size: 12px; font-weight: normal; letter-spacing: 1px; }
        .history-info p { margin: 2px 0 0; color: #888; font-size: 10px; }

        /* æ‰‹åŠ¿é¢„è§ˆçª—å£ */
        #camera-preview {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px;
            background: #000; border: 1px solid #333; border-radius: 8px;
            overflow: hidden; opacity: 0; transition: opacity 0.5s;
        }
        #camera-preview.visible { opacity: 1; border-color: rgba(212, 175, 55, 0.5); }
        #preview-canvas { width: 100%; height: 100%; transform: scaleX(-1); }

        /* æç¤ºæ¡† */
        #toast-container {
            position: absolute; top: 12%; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; pointer-events: none;
        }
        .toast {
            background: rgba(0, 0, 0, 0.7); border: 1px solid rgba(212, 175, 55, 0.3);
            padding: 8px 20px; border-radius: 30px; color: #d4af37; font-size: 14px;
            animation: fadeInOut 3s forwards; display: flex; align-items: center;
            backdrop-filter: blur(4px); box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            letter-spacing: 1px;
        }
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-10px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        /* è¯¦æƒ…æµ®å±‚ - å¢å¼ºæ–‡æœ¬å±•ç¤ºèƒ½åŠ› */
        #card-detail {
            position: absolute; top: 15%; right: 5%; width: 280px; max-height: 70vh;
            background: rgba(15, 15, 20, 0.95); border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 12px; padding: 20px; display: none; color: #fff;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6); backdrop-filter: blur(10px);
            overflow-y: auto; 
        }
        #card-detail::-webkit-scrollbar { width: 4px; }
        #card-detail::-webkit-scrollbar-thumb { background: #d4af37; border-radius: 2px; }
        
        #card-detail h2 { margin: 0 0 8px 0; color: #d4af37; font-size: 18px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }
        
        #card-detail .meaning { 
            font-size: 13px; line-height: 1.6; color: #ccc; 
            margin-top: 10px; 
        }
        #card-detail .meaning strong { color: #fff; font-weight: normal; }
        
        #card-detail .status { display: inline-block; padding: 2px 6px; background: rgba(255,255,255,0.1); border-radius: 4px; font-size: 11px; margin-bottom: 8px; color: #88c0d0; }

        /* å…‰æ ‡ */
        #cursor-ring {
            position: absolute; width: 40px; height: 40px; border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%; pointer-events: none; transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3); display: none; z-index: 100;
            transition: width 0.2s, height 0.2s, border-color 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        #cursor-text { font-size: 10px; color: rgba(255,255,255,0.9); text-shadow: 0 0 4px #000; white-space: nowrap; }

        #scroll-hint {
            position: absolute; bottom: 40px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.2); font-size: 11px; pointer-events: none; letter-spacing: 1px;
        }
    </style>
</head>
<body>

    <!-- åŠ è½½å±‚ -->
    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">æ­£åœ¨åˆå§‹åŒ–ç¥ç§˜é¢†åŸŸ...</div>
        <div style="font-size: 12px; margin-top: 10px; color: #666;">è¿™å¯èƒ½éœ€è¦ä¸€ç‚¹æ—¶é—´</div>
    </div>

    <!-- 3D Canvas å®¹å™¨ -->
    <div id="canvas-container"></div>

    <!-- UI å±‚ -->
    <div id="ui-container">
        <div id="toast-container"></div>

        <a href="index.html" id="home-btn" class="interactive" title="è¿”å›é¦–é¡µ">
            <span>ğŸ </span>
            <span>é¦–é¡µ</span>
        </a>

        <button id="mode-switch" class="interactive">è‡ªåŠ¨æ¨¡å¼</button>

        <button id="history-toggle" class="interactive" title="æŠ½å¡è®°å½•">ğŸ“œ</button>

        <div id="history-panel" class="interactive">
            <div id="history-list"></div>
            <div style="text-align: left; padding-left: 10px; margin-top: 5px;">
                <button onclick="app.clearHistory()" style="font-size: 10px; background:transparent; border:none; color:#555; cursor:pointer; opacity:0.5;">[æ¸…ç©º]</button>
            </div>
        </div>

        <div id="card-detail">
            <h2 id="detail-title">...</h2>
            <span id="detail-status" class="status">...</span>
            <div id="detail-desc" class="meaning">...</div>
        </div>

        <div id="cursor-ring"><span id="cursor-text"></span></div>

        <div id="camera-preview">
            <canvas id="preview-canvas"></canvas>
        </div>

        <div id="scroll-hint">â† ç§»åŠ¨åˆ°è¾¹ç¼˜æ»šåŠ¨ â†’</div>
    </div>

    <!-- å‘¼å¸æ˜Ÿç©º Shader -->
    <script type="x-shader/x-vertex" id="starVertexShader">
        uniform float uTime;
        attribute float aSize;
        attribute float aSpeed;
        varying float vAlpha;

        void main() {
            vec3 pos = position;
            // ç®€å•çš„ç§»åŠ¨é€»è¾‘ï¼Œæ¨¡æ‹Ÿæ›´æ·±é‚ƒçš„ç©ºé—´
            // pos.z += sin(uTime * 0.1 * aSpeed) * 5.0;
            
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            
            // å‘¼å¸é—ªçƒè®¡ç®—
            float twinkle = sin(uTime * aSpeed * 3.0 + pos.x);
            vAlpha = 0.5 + 0.5 * twinkle; // 0.0 - 1.0

            gl_PointSize = aSize * (30.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="starFragmentShader">
        uniform vec3 uColor;
        varying float vAlpha;

        void main() {
            // åœ†å½¢ç²’å­
            vec2 coord = gl_PointCoord - vec2(0.5);
            if(length(coord) > 0.5) discard;
            
            // æ ¸å¿ƒäº®ï¼Œè¾¹ç¼˜æŸ”å’Œ
            float strength = 1.0 - length(coord) * 2.0;
            strength = pow(strength, 2.0);

            gl_FragColor = vec4(uColor, vAlpha * strength);
        }
    </script>

    <script>
        /**
         * 3D å¡”ç½—ç‰Œåº”ç”¨ä¸»é€»è¾‘ 
         */

        const CONFIG = {
            cardWidth: 4.5, 
            cardHeight: 7.7, 
            cardDepth: 0.05,
            spacing: 1.5,
            colors: {
                gold: 0xd4af37,
                bg: 0x050505,
                select: 0xffaa00
            }
        };

        const STATE = {
            mode: 'auto', 
            isCameraReady: false,
            selectedCard: null,
            isRevealing: false,
            history: [],
            cameraPermission: false,
            scrollSpeed: 0,
            handX: 0.5 
        };

        const AudioSys = {
            ctx: null,
            lastHoverTime: 0, 
            init: function() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            playTone: function(freq, type, duration, vol=0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playDing: function() { this.playTone(1200, 'sine', 1.5, 0.1); },
            playHover: function() { 
                const now = Date.now();
                if (now - this.lastHoverTime < 150) return;
                this.lastHoverTime = now;
                this.playTone(200, 'triangle', 0.1, 0.05); 
            },
            playFlip: function() {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
                const filter = this.ctx.createBiquadFilter();
                filter.type = "lowpass";
                filter.frequency.value = 1000;
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            },
            playMagic: function() {
                if (!this.ctx) return;
                this.playTone(400, 'sine', 2.0, 0.2);
                setTimeout(() => this.playTone(600, 'sine', 2.0, 0.1), 200);
                setTimeout(() => this.playTone(800, 'sine', 2.0, 0.1), 400);
            }
        };

        const TextureGen = {
            createCardBack: function() {
                const cvs = document.createElement('canvas');
                cvs.width = 512; cvs.height = 875;
                const ctx = cvs.getContext('2d');
                
                const grad = ctx.createRadialGradient(256, 437, 50, 256, 437, 600);
                grad.addColorStop(0, '#2a2a4e');
                grad.addColorStop(0.5, '#1a1a2e');
                grad.addColorStop(1, '#050510');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,512,875);
                
                ctx.strokeStyle = '#d4af37';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.2;
                ctx.translate(256, 437);
                for(let i=0; i<12; i++) {
                    ctx.rotate(Math.PI / 6);
                    ctx.beginPath();
                    ctx.ellipse(0, 100, 50, 150, 0, 0, Math.PI*2);
                    ctx.stroke();
                }
                ctx.setTransform(1,0,0,1,0,0); 

                ctx.globalAlpha = 1.0;
                ctx.lineWidth = 10;
                ctx.strokeRect(10, 10, 492, 855);
                
                return new THREE.CanvasTexture(cvs);
            },
            
            createCardFace: function(cardData, loadedImage = null) {
                const cvs = document.createElement('canvas');
                cvs.width = 512; cvs.height = 875;
                const ctx = cvs.getContext('2d');
                
                // æ·±è‰²èƒŒæ™¯ï¼Œé˜²æ­¢ç™½è‰²æ–¹å—
                ctx.fillStyle = '#0a0a10'; 
                ctx.fillRect(0,0,512,875);

                if (loadedImage) {
                    ctx.drawImage(loadedImage, 0, 0, 512, 875);
                    const grad = ctx.createLinearGradient(0, 600, 0, 875);
                    grad.addColorStop(0, 'rgba(0,0,0,0)');
                    grad.addColorStop(0.7, 'rgba(0,0,0,0.8)');
                    grad.addColorStop(1, 'rgba(0,0,0,0.9)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 500, 512, 375);
                } else {
                    let baseColor1, baseColor2, accentColor;
                    switch(cardData.id) {
                        case 'strength': baseColor1 = '#4a0e0e'; baseColor2 = '#ff8800'; accentColor='#ffff00'; break; 
                        case 'knight': baseColor1 = '#001a33'; baseColor2 = '#0066cc'; accentColor='#aaddff'; break; 
                        case 'lovers': baseColor1 = '#1a3300'; baseColor2 = '#ff66aa'; accentColor='#ffccff'; break; 
                        default: baseColor1 = '#111'; baseColor2 = '#444'; accentColor='#888';
                    }
                    const grad = ctx.createRadialGradient(256, 350, 0, 256, 400, 600);
                    grad.addColorStop(0, baseColor2); 
                    grad.addColorStop(0.4, baseColor1);
                    grad.addColorStop(1, '#050505');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0,0,512,875);
                    this.drawMandala(ctx, 256, 350, 200, 'rgba(255,255,255,0.05)');
                    this.addNoise(ctx, 512, 875, 0.03);
                    ctx.save();
                    ctx.translate(256, 350);
                    ctx.shadowColor = accentColor;
                    ctx.shadowBlur = 40;
                    this.drawExquisiteSymbol(ctx, cardData.id, accentColor);
                    ctx.restore();
                }

                ctx.strokeStyle = '#d4af37';
                ctx.lineWidth = 14;
                ctx.strokeRect(10, 10, 492, 855);
                ctx.lineWidth = 2;
                ctx.strokeRect(20, 20, 472, 835);

                ctx.shadowBlur = 4; ctx.shadowColor = '#000';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.font = 'bold 44px "Songti SC", serif';
                ctx.fillText(cardData.nameCN, 256, 760);
                
                ctx.fillStyle = '#d4af37';
                ctx.font = 'italic 22px serif';
                ctx.fillText(cardData.nameEN, 256, 800);

                return new THREE.CanvasTexture(cvs);
            },

            addNoise: function(ctx, w, h, amount) {
                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const val = (Math.random() - 0.5) * amount * 255;
                    data[i] += val;
                    data[i+1] += val;
                    data[i+2] += val;
                }
                ctx.putImageData(imgData, 0, 0);
            },

            drawMandala: function(ctx, x, y, radius, color) {
                ctx.save();
                ctx.translate(x, y);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0,0, radius, 0, Math.PI*2); ctx.stroke();
                const petals = 8;
                for(let i=0; i<petals; i++) {
                    ctx.rotate(Math.PI*2/petals);
                    ctx.beginPath();
                    ctx.moveTo(0, radius*0.3);
                    ctx.quadraticCurveTo(radius*0.5, radius*0.5, 0, radius);
                    ctx.stroke();
                }
                ctx.restore();
            },

            drawExquisiteSymbol: function(ctx, id, color) {
                ctx.fillStyle = color;
                ctx.font = '150px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText('ğŸ”®', 0, 0);
            }
        };

        class TarotApp {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.cards = [];
                this.cardGroup = new THREE.Group(); 
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.lastHoveredCard = null; 
                this.starUniforms = { uTime: { value: 0 } };
                
                this.targetScrollX = 0; 
                this.currentScrollX = 0; 
                
                this.deck = [
                    { 
                        id: 'fool', nameCN: 'æ„šäºº', nameEN: 'The Fool', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg',
                        meaningUp: 'æ–°çš„å¼€å§‹ã€çº¯çœŸã€è‡ªå‘æ€§ã€è‡ªç”±ç²¾ç¥ã€æ½œåŠ›ã€‚',
                        meaningRev: 'é²è½ã€è¢«åˆ©ç”¨ã€è½»ç‡ã€é£é™©ã€æ„šè ¢çš„å†³å®šã€‚',
                        desc: 'æ„šäººç«™åœ¨æ‚¬å´–è¾¹ï¼Œè±¡å¾ç€è¸å…¥æœªçŸ¥çš„ä¸–ç•Œï¼Œå……æ»¡æ— é™æ½œåŠ›ï¼Œä½†ä¹Ÿä¼´éšç€é£é™©ã€‚'
                    },
                    { 
                        id: 'magician', nameCN: 'é­”æœ¯å¸ˆ', nameEN: 'The Magician', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg',
                        meaningUp: 'åˆ›é€ åŠ›ã€æŠ€èƒ½ã€æ„å¿—åŠ›ã€è‡ªä¿¡ã€æ˜¾åŒ–èƒ½åŠ›ã€‚',
                        meaningRev: 'æ“çºµã€è®¡åˆ’ä¸å‘¨ã€æ‰èƒ½è¢«åŸ‹æ²¡ã€æ¬ºéª—ã€‚',
                        desc: 'é­”æœ¯å¸ˆä¸€æ‰‹æŒ‡å¤©ä¸€æ‰‹æŒ‡åœ°ï¼Œè±¡å¾ç€å°†ç²¾ç¥åŠ›é‡è½¬åŒ–ä¸ºç°å®ç‰©è´¨çš„èƒ½åŠ›ã€‚'
                    },
                    { 
                        id: 'priestess', nameCN: 'å¥³ç¥­å¸', nameEN: 'The High Priestess', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg',
                        meaningUp: 'ç›´è§‰ã€æ½œæ„è¯†ã€ç¥ç§˜ã€å†…åœ¨çŸ¥è¯†ã€é™æ­¢ã€‚',
                        meaningRev: 'å‹æŠ‘æƒ…æ„Ÿã€ç§˜å¯†æ³„éœ²ã€è‚¤æµ…ã€ç¼ºä¹è¿œè§ã€‚',
                        desc: 'å¥³ç¥­å¸ç«¯åäºé»‘ç™½æŸ±ä¹‹é—´ï¼Œå®ˆæŠ¤ç€æ½œæ„è¯†çš„å¸·å¹•ï¼Œè±¡å¾ç€æœªçŸ¥çš„æ™ºæ…§ã€‚'
                    },
                    { 
                        id: 'empress', nameCN: 'çš‡å', nameEN: 'The Empress', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg',
                        meaningUp: 'ä¸°é¥¶ã€æ¯æ€§ã€è‡ªç„¶ã€æ„Ÿå®˜äº«å—ã€å­•è‚²ã€‚',
                        meaningRev: 'ä¾èµ–ã€åˆ›é€ åŠ›å—é˜»ã€ç©ºè™šã€å®¶åº­é—®é¢˜ã€‚',
                        desc: 'çš‡åç½®èº«äºè‡ªç„¶ä¹‹ä¸­ï¼Œè±¡å¾ç€å¤§åœ°ä¹‹æ¯çš„æ»‹å…»ä¸ç”Ÿå‘½çš„ç¹è£ã€‚'
                    },
                    { 
                        id: 'lovers', nameCN: 'æ‹äºº', nameEN: 'The Lovers', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_06_Lovers.jpg',
                        meaningUp: 'çˆ±ã€å’Œè°ã€å…³ç³»ã€ä»·å€¼è§‚é€‰æ‹©ã€ç»“åˆã€‚',
                        meaningRev: 'ä¸å’Œè°ã€ä¿¡ä»»ç¼ºå¤±ã€åˆ†ç¦»ã€é”™è¯¯çš„é€‰æ‹©ã€‚',
                        desc: 'äºšå½“å’Œå¤å¨ƒåœ¨å¤©ä½¿çš„ç¥ç¦ä¸‹ç»“åˆï¼Œè±¡å¾ç€å¯¹ç«‹é¢çš„ç»Ÿä¸€ä¸çˆ±çš„åŠ›é‡ã€‚'
                    },
                    { 
                        id: 'strength', nameCN: 'åŠ›é‡', nameEN: 'Strength', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/f/f5/RWS_Tarot_08_Strength.jpg',
                        meaningUp: 'å‹‡æ°”ã€è€å¿ƒã€æ§åˆ¶ã€åŒæƒ…å¿ƒã€å†…åœ¨åŠ›é‡ã€‚',
                        meaningRev: 'è‡ªæˆ‘æ€€ç–‘ã€è½¯å¼±ã€ä¸å®‰å…¨æ„Ÿã€æ»¥ç”¨åŠ›é‡ã€‚',
                        desc: 'å¥³å­æ¸©æŸ”åœ°æŠšæ‘¸ç€ç‹®å­ï¼Œè±¡å¾ç€ä»¥æŸ”å…‹åˆšï¼Œç”¨å†…å¿ƒçš„åŠ›é‡é©¯æœåŸå§‹æœ¬èƒ½ã€‚'
                    },
                    { 
                        id: 'hermit', nameCN: 'éšå£«', nameEN: 'The Hermit', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/4/4d/RWS_Tarot_09_Hermit.jpg',
                        meaningUp: 'å†…çœã€ç‹¬å¤„ã€å¯»æ±‚çœŸç†ã€æŒ‡å¼•ã€å®¡æ…ã€‚',
                        meaningRev: 'å­¤ç«‹ã€å¯‚å¯ã€æ‹’ç»å»ºè®®ã€è¿·å¤±æ–¹å‘ã€‚',
                        desc: 'éšå£«æç€çœŸç†ä¹‹ç¯åœ¨é›ªå±±ç‹¬è¡Œï¼Œè±¡å¾ç€å‘å†…æ¢ç´¢ï¼Œå¯»æ±‚æ™ºæ…§çš„æ—…ç¨‹ã€‚'
                    },
                    { 
                        id: 'wheel', nameCN: 'å‘½è¿ä¹‹è½®', nameEN: 'Wheel of Fortune', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg',
                        meaningUp: 'å‘¨æœŸã€å˜åŒ–ã€å‘½è¿ã€è½¬æŠ˜ç‚¹ã€å¥½è¿ã€‚',
                        meaningRev: 'åè¿æ°”ã€é˜»åŠ›ã€ä¸å¯æ§çš„å˜åŠ¨ã€å¾ªç¯æ‰“ç ´ã€‚',
                        desc: 'å‘½è¿ä¹‹è½®ä¸åœè½¬åŠ¨ï¼Œè±¡å¾ç€ä¸–äº‹æ— å¸¸ï¼Œé¡ºåº”å˜åŒ–æ˜¯å”¯ä¸€çš„æ°¸æ’ã€‚'
                    },
                    { 
                        id: 'death', nameCN: 'æ­»ç¥', nameEN: 'Death', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/d/d7/RWS_Tarot_13_Death.jpg',
                        meaningUp: 'ç»“æŸã€è½¬å˜ã€æ”¾ä¸‹ã€æ–°ç”Ÿã€ä¸å¯é¿å…çš„æ”¹å˜ã€‚',
                        meaningRev: 'æŠ—æ‹’æ”¹å˜ã€åœæ»ä¸å‰ã€æ— æ³•é‡Šæ€€ã€ææƒ§ã€‚',
                        desc: 'æ­»ç¥éª‘ç€ç™½é©¬è€Œæ¥ï¼Œå¹¶éä»£è¡¨è‚‰ä½“æ­»äº¡ï¼Œè€Œæ˜¯æ—§äº‹ç‰©çš„ç»ˆç»“ä¸æ–°äº‹ç‰©çš„å¼€å§‹ã€‚'
                    },
                    { 
                        id: 'devil', nameCN: 'æ¶é­”', nameEN: 'The Devil', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/5/55/RWS_Tarot_15_Devil.jpg',
                        meaningUp: 'æŸç¼šã€ç‰©è´¨ä¸»ä¹‰ã€è¯±æƒ‘ã€é˜´å½±ã€æˆç˜¾ã€‚',
                        meaningRev: 'æ‰“ç ´æŸç¼šã€é‡è·è‡ªç”±ã€é¢å¯¹é˜´æš—é¢ã€‚',
                        desc: 'è¢«é”é“¾æŸç¼šçš„äººä»¬çœ‹ä¼¼æ— åŠ›ï¼Œå®åˆ™é”é“¾æ¾å®ï¼Œè±¡å¾ç€è®¸å¤šæŸç¼šæºäºè‡ªæ„¿ã€‚'
                    },
                    { 
                        id: 'tower', nameCN: 'é«˜å¡”', nameEN: 'The Tower', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/5/53/RWS_Tarot_16_Tower.jpg',
                        meaningUp: 'çªå˜ã€æ··ä¹±ã€å¯ç¤ºã€è§‰é†’ã€æ¯ç­æ—§æœ‰ç»“æ„ã€‚',
                        meaningRev: 'é¿å…ç¾éš¾ã€ææƒ§æ”¹å˜ã€å‹‰å¼ºç»´æŒã€é‡å»ºã€‚',
                        desc: 'é«˜å¡”è¢«é›·ç”µå‡»ä¸­ï¼Œçš‡å† å è½ï¼Œè±¡å¾ç€å»ºç«‹åœ¨è™šå‡åŸºç¡€ä¸Šçš„äº‹ç‰©å¿…å°†å´©å¡Œã€‚'
                    },
                    { 
                        id: 'star', nameCN: 'æ˜Ÿæ˜Ÿ', nameEN: 'The Star', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg',
                        meaningUp: 'å¸Œæœ›ã€çµæ„Ÿã€å®é™ã€ç²¾ç¥æŒ‡å¼•ã€æ²»æ„ˆã€‚',
                        meaningRev: 'ç»æœ›ã€ç¼ºä¹ä¿¡å¿ƒã€æ¶ˆæã€é”™å¤±æœºä¼šã€‚',
                        desc: 'è£¸ä½“å¥³å­åœ¨æ˜Ÿç©ºä¸‹å€’æ°´ï¼Œè±¡å¾ç€æ½œæ„è¯†çš„æ»‹å…»ä¸å¸Œæœ›ä¹‹å…‰çš„æŒ‡å¼•ã€‚'
                    },
                    { 
                        id: 'moon', nameCN: 'æœˆäº®', nameEN: 'The Moon', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/7/7f/RWS_Tarot_18_Moon.jpg',
                        meaningUp: 'å¹»è§‰ã€ææƒ§ã€æ½œæ„è¯†ã€ç›´è§‰ã€ä¸å®‰ã€‚',
                        meaningRev: 'æ··ä¹±å¹³æ¯ã€æ­ç¤ºçœŸç›¸ã€å…‹æœææƒ§ã€‚',
                        desc: 'æœˆäº®æ˜ ç…§å‡ºå……æ»¡æœªçŸ¥çš„è·¯å¾„ï¼Œè±¡å¾ç€æ½œæ„è¯†ä¸­çš„ææƒ§ä¸ç›´è§‰çš„æ¨¡ç³Šç•Œé™ã€‚'
                    },
                    { 
                        id: 'sun', nameCN: 'å¤ªé˜³', nameEN: 'The Sun', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg',
                        meaningUp: 'å¿«ä¹ã€æˆåŠŸã€æ´»åŠ›ã€æ¸…æ™°ã€æ¸©æš–ã€‚',
                        meaningRev: 'æš‚æ—¶ä½è½ã€è¿‡åº¦ä¹è§‚ã€è™šè£ã€å»¶è¿Ÿçš„æˆåŠŸã€‚',
                        desc: 'é˜³å…‰æ™®ç…§ï¼Œå­©ç«¥éª‘ç€ç™½é©¬æ¬¢ç¬‘ï¼Œè±¡å¾ç€çº¯ç²¹çš„å¿«ä¹ä¸ç”Ÿå‘½çš„æ´»åŠ›ã€‚'
                    },
                    { 
                        id: 'world', nameCN: 'ä¸–ç•Œ', nameEN: 'The World', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg',
                        meaningUp: 'å®Œæˆã€æ•´åˆã€æˆå°±ã€æ—…è¡Œã€åœ†æ»¡ã€‚',
                        meaningRev: 'æœªå®Œæˆã€ç¼ºä¹é—­ç¯ã€åœæ»ã€å»¶è¯¯ã€‚',
                        desc: 'è¢«æ¡‚å† ç¯ç»•çš„èˆè€…ï¼Œè±¡å¾ç€æ—…ç¨‹çš„ç»ˆç‚¹ä¸å®Œç¾çš„å’Œè°ç»Ÿä¸€ã€‚'
                    },
                    { 
                        id: 'knight_swords', nameCN: 'å®å‰‘éª‘å£«', nameEN: 'Knight of Swords', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/b/b0/Swords12.jpg',
                        meaningUp: 'è¡ŒåŠ¨ã€å†²åŠ¨ã€æ²Ÿé€šã€é‡å¿ƒã€è¿…é€Ÿã€‚',
                        meaningRev: 'é²è½ã€è¨€è¯­æ”»å‡»ã€æ€¥èºã€æ··ä¹±ã€‚',
                        desc: 'éª‘å£«ç­–é©¬é£å¥”ï¼ŒæŒ¥èˆå®å‰‘ï¼Œè±¡å¾ç€æ€æƒ³ä¸è¡ŒåŠ¨çš„æé€Ÿç»“åˆã€‚'
                    },
                    { 
                        id: 'wands5', nameCN: 'æƒæ–äº”', nameEN: 'Five of Wands', 
                        img: 'https://upload.wikimedia.org/wikipedia/commons/6/6b/Wands05.jpg',
                        meaningUp: 'å†²çªã€ç«äº‰ã€åˆ†æ­§ã€æŒ‘æˆ˜ã€æ··ä¹±ã€‚',
                        meaningRev: 'é¿å…å†²çªã€è¾¾æˆå…±è¯†ã€å¹³æ¯äº‰ç«¯ã€‚',
                        desc: 'äº”äººä¸¾èµ·æƒæ–æ··æˆ˜ï¼Œè±¡å¾ç€ä¸åŒæ„å¿—çš„ç¢°æ’ä¸è‰¯æ€§çš„ç«äº‰ã€‚'
                    }
                ];

                this.deck = [...this.deck, ...this.deck]; 
                
                this.init();
            }

            init() {
                this.setupScene();
                this.createCards();
                this.createStarfield();
                this.setupEvents();
                this.setupMediaPipe(); 
                this.animate();
                
                document.getElementById('loader').style.display = 'flex';
                document.getElementById('mode-switch').addEventListener('click', () => this.toggleMode());
                document.getElementById('history-toggle').addEventListener('click', () => {
                    document.getElementById('history-panel').classList.toggle('open');
                });
            }

            setupScene() {
                const container = document.getElementById('canvas-container');
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050505, 0.015);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.z = 18; 
                this.camera.position.y = 1;
                this.camera.lookAt(0,0,0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                container.appendChild(this.renderer.domElement);

                this.scene.add(this.cardGroup);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffd700, 0.8);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                this.scene.add(dirLight);

                const pointLight = new THREE.PointLight(0x88c0d0, 0.5, 50);
                pointLight.position.set(0, 5, 5);
                this.scene.add(pointLight);
            }

            // æ–°å¢ï¼šå‘¼å¸æ˜Ÿç©º (Shader)
            createStarfield() {
                const geometry = new THREE.BufferGeometry();
                const count = 4000;
                const positions = new Float32Array(count * 3);
                const sizes = new Float32Array(count);
                const speeds = new Float32Array(count);

                for(let i=0; i<count*3; i+=3) {
                    positions[i] = (Math.random() - 0.5) * 300;
                    positions[i+1] = (Math.random() - 0.5) * 300;
                    positions[i+2] = (Math.random() - 0.5) * 200 - 50;
                    
                    sizes[i/3] = Math.random() * 2.0;
                    speeds[i/3] = 0.5 + Math.random() * 1.5;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));

                const material = new THREE.ShaderMaterial({
                    uniforms: this.starUniforms,
                    vertexShader: document.getElementById('starVertexShader').textContent,
                    fragmentShader: document.getElementById('starFragmentShader').textContent.replace('uniform vec3 uColor;', 'const vec3 uColor = vec3(1.0, 1.0, 1.0);'),
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.stars = new THREE.Points(geometry, material);
                this.scene.add(this.stars);
            }

            createCards() {
                const backTexture = TextureGen.createCardBack();
                const geometry = new THREE.BoxGeometry(CONFIG.cardWidth, CONFIG.cardHeight, CONFIG.cardDepth);
                const backMat = new THREE.MeshStandardMaterial({ map: backTexture, roughness: 0.4, metalness: 0.3 });
                const sideMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

                const totalCards = this.deck.length;

                this.deck.forEach((cardData, index) => {
                    const placeholderTex = TextureGen.createCardFace(cardData);
                    const faceMat = new THREE.MeshStandardMaterial({ 
                        map: placeholderTex, 
                        roughness: 0.3, 
                        metalness: 0.1,
                        color: 0xffffff // Ensure base color is normal
                    });
                    
                    const materials = [sideMat, sideMat, sideMat, sideMat, faceMat, backMat];
                    const card = new THREE.Mesh(geometry, materials);
                    
                    const x = (index - (totalCards-1)/2) * (CONFIG.cardWidth + CONFIG.spacing);
                    
                    card.position.set(x, 0, 0);
                    card.rotation.y = Math.PI; 
                    
                    card.userData = {
                        id: cardData.id,
                        baseX: x, 
                        isHovered: false,
                        index: index,
                        data: cardData,
                        isTextureLoaded: false
                    };
                    
                    if (cardData.img) {
                        const img = new Image();
                        img.crossOrigin = "anonymous";
                        img.onload = () => {
                            const newTexture = TextureGen.createCardFace(cardData, img);
                            newTexture.encoding = THREE.sRGBEncoding;
                            card.material[4].map = newTexture;
                            card.material[4].needsUpdate = true;
                            card.userData.isTextureLoaded = true;
                        };
                        img.onerror = () => {
                            console.warn(`Image load failed for ${cardData.nameCN}`);
                        };
                        img.src = cardData.img;
                    }

                    this.cardGroup.add(card);
                    this.cards.push(card);
                });
            }

            setupEvents() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    STATE.handX = e.clientX / window.innerWidth;
                    if(STATE.mode === 'mouse') this.handleInteraction(this.mouse.x, this.mouse.y, 'hover');
                });

                window.addEventListener('dblclick', () => {
                    if(STATE.mode === 'mouse') this.handleInteraction(this.mouse.x, this.mouse.y, 'click');
                });
            }

            handleInteraction(x, y, actionType) {
                if (STATE.isRevealing) return;

                this.raycaster.setFromCamera({x, y}, this.camera);
                const intersects = this.raycaster.intersectObjects(this.cards);

                if (intersects.length > 0) {
                    const target = intersects[0].object;
                    
                    // è§£å†³æŠ–åŠ¨ï¼šåªæœ‰å½“ç›®æ ‡å¡ç‰Œæ”¹å˜æ—¶æ‰è§¦å‘é€»è¾‘
                    if (target !== this.lastHoveredCard) {
                        // 1. å¤ä½ä¸Šä¸€å¼ å¡ç‰Œ (å¦‚æœå­˜åœ¨)
                        if (this.lastHoveredCard && this.lastHoveredCard !== STATE.selectedCard) {
                            gsap.to(this.lastHoveredCard.position, { y: 0, z: 0, duration: 0.3 });
                            gsap.to(this.lastHoveredCard.scale, { x: 1, y: 1, z: 1, duration: 0.3 });
                            this.lastHoveredCard.userData.isHovered = false;
                        }

                        // 2. æ¿€æ´»æ–°å¡ç‰Œ
                        if (target !== STATE.selectedCard) {
                            this.lastHoveredCard = target;
                            target.userData.isHovered = true;
                            AudioSys.playHover();
                            
                            gsap.to(target.position, { y: 1, z: 2, duration: 0.3 }); 
                            gsap.to(target.scale, { x: 1.1, y: 1.1, z: 1.1, duration: 0.3 });
                            document.getElementById('cursor-ring').style.borderColor = '#d4af37';
                        }
                    }

                    // ç‚¹å‡»é€»è¾‘
                    if (actionType === 'click' || actionType === 'fist') {
                        this.selectCard(target);
                    }
                } else {
                    // ç§»å‡ºæ‰€æœ‰å¡ç‰Œ
                    if (this.lastHoveredCard && this.lastHoveredCard !== STATE.selectedCard) {
                        gsap.to(this.lastHoveredCard.position, { y: 0, z: 0, duration: 0.3 });
                        gsap.to(this.lastHoveredCard.scale, { x: 1, y: 1, z: 1, duration: 0.3 });
                        this.lastHoveredCard.userData.isHovered = false;
                        this.lastHoveredCard = null;
                    }
                    document.getElementById('cursor-ring').style.borderColor = 'rgba(255,255,255,0.8)';
                }
            }

            updateScroll() {
                if(STATE.isRevealing) return;

                const edgeThreshold = 0.15; 
                const maxSpeed = 0.15; 
                let speed = 0;

                if (STATE.handX < edgeThreshold) {
                    speed = (edgeThreshold - STATE.handX) / edgeThreshold * maxSpeed;
                } else if (STATE.handX > (1.0 - edgeThreshold)) {
                    speed = -((STATE.handX - (1.0 - edgeThreshold)) / edgeThreshold * maxSpeed);
                }

                const totalWidth = this.cards.length * (CONFIG.cardWidth + CONFIG.spacing);
                const maxScroll = totalWidth / 2;
                const minScroll = -totalWidth / 2;

                if (Math.abs(speed) > 0.001) {
                    this.targetScrollX += speed * 5; 
                    this.targetScrollX = Math.max(minScroll, Math.min(maxScroll, this.targetScrollX));
                }

                this.currentScrollX += (this.targetScrollX - this.currentScrollX) * 0.1;
                this.cardGroup.position.x = this.currentScrollX;
            }

            selectCard(card) {
                if (STATE.selectedCard === card || STATE.isRevealing) return;
                
                STATE.selectedCard = card;
                STATE.isRevealing = true;
                AudioSys.playDing();
                this.showToast('å‘½è¿å·²é”å®š...', 'info');

                const worldPos = new THREE.Vector3();
                card.getWorldPosition(worldPos);
                this.scene.attach(card); 

                // 1. ç§»åŠ¨ + æ—‹è½¬
                gsap.to(card.position, {
                    x: 0, y: 0, z: 10, 
                    duration: 1.2, 
                    ease: "power2.out"
                });

                // 2. ç›´æ¥æ—‹è½¬åˆ°æ­£é¢
                gsap.to(card.rotation, {
                    x: 0, y: 0, z: 0, 
                    duration: 1.2,
                    ease: "power2.out",
                    onComplete: () => {
                        AudioSys.playMagic();
                        const isReversed = Math.random() < 0.5;
                        
                        // æ˜¾ç¤ºè¯¦ç»†è§£è¯»
                        this.showCardDetail(card, isReversed);
                        this.addToHistory(card, isReversed);
                        
                        // å»¶è¿Ÿåè§¦å‘æ¶ˆå¤±åŠ¨ç”» (çº¯å‡€ç‰ˆ)
                        setTimeout(() => {
                            this.animateCardExit(card);
                        }, 4000); 
                    }
                });
            }

            // æ— ç²’å­çš„çº¯å‡€æ¶ˆå¤±åŠ¨ç”» - å…‰é€Ÿé£å‡
            animateCardExit(card) {
                // 1. è“„åŠ›å‘å…‰
                if(card.material[4]) { // Face material
                    gsap.to(card.material[4].emissive, {r:0.5, g:0.5, b:0.5, duration: 0.5});
                }

                // 2. å‰§çƒˆæ‹‰ä¼¸ + é£å‡º (Warp Drive Effect)
                gsap.to(card.scale, {
                    x: 0.1, y: 5.0, z: 0.1, // æ‹‰æˆç»†é•¿æ¡
                    duration: 0.4, 
                    ease: "power2.in",
                    delay: 0.5
                });

                gsap.to(card.position, {
                    y: 100, // ç¬é—´é£èµ°
                    duration: 0.4, 
                    ease: "power2.in",
                    delay: 0.5,
                    onComplete: () => {
                        this.scene.remove(card);
                        this.resetGame();
                    }
                });

                // 3. ç«‹å³è§¦å‘å…¶ä»–å¡ç‰Œè¡¥ä½
                const idx = this.cards.indexOf(card);
                if (idx > -1) {
                    this.cards.splice(idx, 1);
                    this.rearrangeCards();
                }
            }

            showCardDetail(card, isReversed) {
                const ui = document.getElementById('card-detail');
                const data = card.userData.data;
                
                document.getElementById('detail-title').innerText = `${data.nameCN} ${data.nameEN}`;
                
                const statusText = document.getElementById('detail-status');
                const descBox = document.getElementById('detail-desc');
                
                if(isReversed) {
                    statusText.innerText = "é€†ä½ (Reversed)";
                    statusText.style.color = "#ff6b6b";
                    descBox.innerHTML = `<strong>ğŸ”® è§£è¯»ï¼š</strong><br>${data.meaningRev}<br><br><strong>ğŸ“– ç‰Œé¢ï¼š</strong><br>${data.desc}`;
                } else {
                    statusText.innerText = "æ­£ä½ (Upright)";
                    statusText.style.color = "#88c0d0";
                    descBox.innerHTML = `<strong>ğŸ”® è§£è¯»ï¼š</strong><br>${data.meaningUp}<br><br><strong>ğŸ“– ç‰Œé¢ï¼š</strong><br>${data.desc}`;
                }
                
                ui.style.display = 'block';
                gsap.fromTo(ui, {opacity:0, x: 50}, {opacity:1, x:0, duration: 0.5});
            }

            addToHistory(card, isReversed) {
                const list = document.getElementById('history-list');
                const data = card.userData.data;
                const div = document.createElement('div');
                div.className = 'history-item';
                div.innerHTML = `
                    <div class="history-thumb" style="background-color:#222; background-image:url('${data.img || ''}');"></div>
                    <div class="history-info">
                        <h4>${data.nameCN} <span style="color:${isReversed?'#ff6b6b':'#88c0d0'}">${isReversed?'(é€†)':'(æ­£)'}</span></h4>
                        <p>${new Date().toLocaleTimeString().slice(0,5)}</p>
                    </div>
                `;
                if(STATE.history.length === 0) list.innerHTML = '';
                list.prepend(div);
                STATE.history.push(data);
            }
            
            clearHistory() {
                document.getElementById('history-list').innerHTML = '';
                STATE.history = [];
            }

            rearrangeCards() {
                const total = this.cards.length;
                this.cards.forEach((card, i) => {
                    const newBaseX = (i - (total - 1) / 2) * (CONFIG.cardWidth + CONFIG.spacing);
                    card.userData.baseX = newBaseX;
                    gsap.to(card.position, {
                        x: newBaseX,
                        duration: 1.0,
                        ease: "power2.inOut"
                    });
                });
            }

            resetGame() {
                STATE.isRevealing = false;
                STATE.selectedCard = null;
                this.lastHoveredCard = null; 
                document.getElementById('card-detail').style.display = 'none';
                this.showToast('å¡ç‰Œå·²å½’ä½ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡æŠ½é€‰', 'info');
            }

            async setupMediaPipe() {
                const videoElement = document.createElement('video');
                const canvasElement = document.getElementById('preview-canvas');
                const canvasCtx = canvasElement.getContext('2d');

                const startMouseMode = (msg) => {
                    console.warn(msg);
                    STATE.cameraPermission = false;
                    STATE.mode = 'mouse';
                    document.getElementById('loader').style.display = 'none';
                    this.showToast(msg, 'warn');
                    document.getElementById('mode-switch').innerText = "æ¨¡å¼ï¼šé¼ æ ‡";
                };

                if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                    startMouseMode("ä¸æ”¯æŒæ‘„åƒå¤´ï¼Œåˆ‡æ¢è‡³é¼ æ ‡");
                    return;
                }

                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    if (videoDevices.length === 0) {
                        startMouseMode("æ— æ‘„åƒå¤´ï¼Œåˆ‡æ¢è‡³é¼ æ ‡");
                        return;
                    }
                } catch (err) {
                    startMouseMode("è®¾å¤‡æ£€æµ‹å¤±è´¥ï¼Œåˆ‡æ¢è‡³é¼ æ ‡");
                    return;
                }

                const onResults = (results) => {
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);

                    canvasCtx.save();
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                    
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const landmarks = results.multiHandLandmarks[0];
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
                        drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1});
                        this.processGestures(landmarks);
                    } else {
                        document.getElementById('cursor-ring').style.display = 'none';
                    }
                    canvasCtx.restore();
                };

                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
                hands.onResults(onResults);

                try {
                    const camera = new Camera(videoElement, {
                        onFrame: async () => { await hands.send({image: videoElement}); },
                        width: 320, height: 240
                    });

                    await camera.start();
                    
                    STATE.isCameraReady = true;
                    STATE.cameraPermission = true;
                    STATE.mode = 'hand';
                    document.getElementById('mode-switch').innerText = "æ¨¡å¼ï¼šæ‰‹åŠ¿";
                    document.getElementById('camera-preview').classList.add('visible');
                    this.showToast('æ‘„åƒå¤´å·²è¿æ¥ï¼Œå¯ç”¨æ‰‹åŠ¿', 'info');
                } catch (err) {
                    console.error("Camera start failed:", err);
                    startMouseMode("æ‘„åƒå¤´è®¿é—®å¤±è´¥ï¼Œåˆ‡æ¢è‡³é¼ æ ‡");
                }
            }

            processGestures(landmarks) {
                if(STATE.mode !== 'hand') return;

                const palmX = 1 - landmarks[9].x; 
                const palmY = landmarks[9].y;
                
                STATE.handX = palmX;

                const ndcX = (palmX * 2) - 1;
                const ndcY = -(palmY * 2) + 1;

                const ring = document.getElementById('cursor-ring');
                ring.style.display = 'flex';
                ring.style.left = `${palmX * 100}%`;
                ring.style.top = `${palmY * 100}%`;

                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                
                const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
                const isThumbOpen = dist(thumbTip, indexTip) > 0.1;
                const isIndexOpen = indexTip.y < landmarks[6].y;
                const isMiddleOpen = middleTip.y < landmarks[10].y;
                const isRingOpen = ringTip.y < landmarks[14].y;
                const isPinkyOpen = pinkyTip.y < landmarks[18].y;

                const isPinch = dist(thumbTip, indexTip) < 0.05;
                const isFist = !isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen;
                const isPoint = isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen;

                const textEl = document.getElementById('cursor-text');
                let action = 'hover';

                if (isFist) {
                    textEl.innerText = "ç¡®è®¤";
                    ring.style.borderColor = "#ff4d4d";
                    action = 'fist';
                } else if (isPinch) {
                    textEl.innerText = "æŠ“å–";
                    ring.style.borderColor = "#00ff00";
                    action = 'pinch';
                } else if (isPoint) {
                    textEl.innerText = "æŸ¥çœ‹";
                    ring.style.borderColor = "#d4af37";
                    action = 'point';
                } else {
                    textEl.innerText = "";
                    ring.style.borderColor = "rgba(255,255,255,0.8)";
                    action = 'hover';
                }

                this.handleInteraction(ndcX, ndcY, action);
            }

            toggleMode() {
                if (STATE.mode === 'hand') {
                    STATE.mode = 'mouse';
                    document.getElementById('mode-switch').innerText = "æ¨¡å¼ï¼šé¼ æ ‡";
                    document.getElementById('cursor-ring').style.display = 'none';
                    this.showToast('å·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼', 'info');
                } else {
                    if (STATE.cameraPermission) {
                        STATE.mode = 'hand';
                        document.getElementById('mode-switch').innerText = "æ¨¡å¼ï¼šæ‰‹åŠ¿";
                        this.showToast('å·²åˆ‡æ¢è‡³æ‰‹åŠ¿æ¨¡å¼', 'info');
                    } else {
                        this.setupMediaPipe();
                    }
                }
            }

            showToast(msg, type='info') {
                const container = document.getElementById('toast-container');
                const div = document.createElement('div');
                div.className = `toast ${type}`;
                div.innerText = msg;
                container.appendChild(div);
                setTimeout(() => div.remove(), 3000);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updateScroll();

                if(this.stars) {
                    this.starUniforms.uTime.value += 0.01; // æ›´æ–°æ˜Ÿæ˜Ÿå‘¼å¸
                    this.stars.rotation.y += 0.0005;
                }

                const time = Date.now() * 0.001;
                // ç§»é™¤æ‰€æœ‰å¯èƒ½å¯¼è‡´æŠ–åŠ¨çš„è‡ªè½¬é€»è¾‘
                // this.cards.forEach(card => ...); 

                this.renderer.render(this.scene, this.camera);
            }
        }

        window.onload = () => {
            AudioSys.init(); 
            window.app = new TarotApp();
            document.body.addEventListener('click', () => {
                if(AudioSys.ctx && AudioSys.ctx.state === 'suspended') {
                    AudioSys.ctx.resume();
                }
            }, {once:true});
        };

    </script>
</body>
</html>